require 'typelib'
module Rbind
    module Typelib
        class << self
            # @return [Typelib::Registry] The typelib registry that should be used by Typelib.to_typelib
            attr_accessor :registry
        end
        self.registry = ::Typelib::Registry.new

        # Converts +rbind+ into a Typelib value
        #
        # @param [Object] rbind the Rbind-generated representation of the type.
        #   It has to own the underlying memory
        # @param [String] typename the Typelib type name into which this type
        #   should be represented
        # @return [Typelib::Type,nil] the converted value or nil if Typelib.registry
        #   does not contain the requested type
        def self.to_typelib(klass, rbind, typename)
            if rbind.kind_of?(FFI::Pointer)
                rbind = klass.rbind_struct.new(rbind)
            end
            if rbind.kind_of?(klass.rbind_struct)
                if !rbind[:bowner]
                    raise ArgumentError, "cannot convert #{rbind}: it does not own the underlying memory"
                end
                if registry.include?(typename)
                    rbind[:bowner] = false
                    typelib_t = registry.get(typename)
                    typelib_value = ::Typelib.to_ruby(typelib_t.from_address(rbind[:obj_ptr].address))
                    rbind.instance_variable_set :@__typelib_original_value__, typelib_value
                    typelib_value
                end
            end

        end

        # Converts +obj+ into the FFI::Struct that rbind uses to initialize its Ruby
        # types (one of the XXXXStruct types generated by Rbind)
        #
        # @param [Class<FFI::Struct>] klass the FFI::Struct type
        # @param [Object] obj the object to be converted
        # @param [Array<String>] typenames the Typelib type names that are known to
        #   be equivalents of the FFI::Struct represented by klass
        # @return [FFI::Struct,nil] the converted struct or nil if the obj argument
        #   is not a typelib type
        # @raise ArgumentError if 'obj' is a typelib type, but not of one of the
        #   expected typenames
        def self.from_typelib(klass, obj, *typenames)
            typelib_value = nil
            typenames.each do |tn|
                target_t = registry.build(tn)
                begin
                    typelib_value = ::Typelib.from_ruby(obj, target_t)
                rescue ArgumentError
                end
            end
            if typelib_value
                s = klass.rbind_struct.new
                s[:obj_ptr]  = typelib_value.to_memory_ptr.zone_address
                s[:bowner] = false
                s[:size] = 0 #obj.marshalling_size
                s[:type_id] = nil
                s[:version] = 1
                s.instance_variable_set :@__typelib_original_value__, typelib_value
                s
            elsif obj.kind_of?(::Typelib::Type)
                raise ArgumentError, "#{obj} is a typelib type, but I don't know how to convert it to #{klass}. Expected one of #{typenames.sort.join(", ")}"
            end
        end
    end
end

